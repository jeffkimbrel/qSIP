# Define a function to fit a normal distribution to a cdf:
# Given an x (e.g. dna density) and a z (e.g. expressed in the form of a cdf), fit a normal distribution and return stats.
#
#			output = fit.norm.func(x, z, CI)
#
#			x: data in x (e.g. dna density)
#			z: data in y (expressed in the form of a cdf; i.e., from 0 to 1)
#			CI: confidence interval (0-1)
#			-------------------------------------------------------
#			output: list of: convergence, mean, stdev, NLL, meanCI (lower and upper), stdevCI (lower, upper)

fit.norm.func <-	function(x, z, CI){

# I Calculate the normal cdf fit to the data for the parameters specified and uses 
	#this for the mean in a normal distribution to find the NLL for the specified parameters.
	#(i.e., this is a regression problem, using the normal cdf as the regression model)
    NLL.norm.func <-	function(parm, x, z){
		  	  Zhats <- pnorm(x, mean=parm[1], sd=parm[2])
		  	  NLLset <- c()
		  	  for (i in 1:length(z)){
			    NLLset[i] <- -log(dnorm(z[i], mean=Zhats[i], sd=sd(z)))
			  }
			  NLL <- sum(NLLset)
			  NLL
			}

# II Calculate NLLs for the data across a range of parameter values:
    NLLall.norm.func <-	function(m.lo, m.hi, m.inc, sd.lo, sd.hi, sd.inc, x, z){
			  means <- seq(m.lo, m.hi, m.inc)
			  stdevs <- seq(sd.lo, sd.hi, sd.inc)
			  NLLmat <- matrix(nrow=length(means), ncol=length(stdevs))
			  for (r in 1:length(means)){
			    for (d in 1:length(stdevs)){
			      NLLmat[r,d] <- NLL.norm.func(parm=c(means[r], stdevs[d]), x=x, z=z)
			    }
			  }
			  output <- list(means=means, stdevs=stdevs, NLLmat=NLLmat)
			  output
			}
	
# III Function that writes 'NA' to all values of the list generated by optim when it throws an error:
    error.optim.func <-	function(){
			  counts <- as.integer(c(NA,NA), length=2)
			  convergence <- as.integer(NA)
			  names(counts) <- c("function", "gradient")
			  list(par=c(NA,NA), value=NA, counts=counts, convergence=convergence)
			}

# IV Function that catches errors at the optimization step (either data errors or optim errors), and calls the function above rather than halting 
    robust.optim <-	function(par, fn, gr=NULL, ..., method, lower=-Inf, upper=Inf, control, hessian=FALSE){
			  tryCatch(optim(par, fn, gr=gr, ..., method=method, lower=lower, upper=upper, control=control, hessian=hessian), error=function(cond){message(cond); error.optim.func()})
			}
	
# Define a wrapper function to fit normal distribution and return stats:
 #start.values = candidate parameters (mean & stdev) for normal distribution
 #fn = the function to minimize
 #x = data in x (e.g., density)
 #z = data in y (expressed in the form of a cdf; i.e., from 0 to 1)
 #CI = the confidence interval you want returned (0-1)
  x <- x[order(x)]	#Sort the data according to ascending x
  z <- z[order(x)]	#Sort the data according to ascending x
	
	start.values <- c(mean(x), 0.1*mean(x))
	outNM <- robust.optim(par=start.values, fn=NLL.norm.func, x=x, z=z, method="Nelder-Mead", control=list(trace=1, maxit=10000))
			if (!is.na(outNM$convergence) & outNM$convergence == 0){
			  NLL.crit <- outNM$value+(0.5*(qchisq(p=(CI), df=2)))
			  NLLall.means <- NLLall.norm.func(m.lo=outNM$par[1]*(1-0.05), m.hi=outNM$par[1]*(1+0.05), m.inc=(0.1*outNM$par[1])/2500, sd.lo=outNM$par[2], sd.hi=outNM$par[2], sd.inc=0, x=x, z=z)
			  NLLall.stdevs <- NLLall.norm.func(m.lo=outNM$par[1], m.hi=outNM$par[1], m.inc=0, sd.lo=0, sd.hi=10*outNM$par[2], sd.inc=(10*outNM$par[2])/1000, x=x, z=z)
			  mean.LCI <- min(NLLall.means$means[NLLall.means$NLLmat <= NLL.crit], na.rm=TRUE)
			  mean.UCI <- max(NLLall.means$means[NLLall.means$NLLmat <= NLL.crit], na.rm=TRUE)
			  stdev.LCI <- min(NLLall.stdevs$stdevs[NLLall.stdevs$NLLmat <= NLL.crit], na.rm=TRUE)
			  stdev.UCI <- max(NLLall.stdevs$stdevs[NLLall.stdevs$NLLmat <= NLL.crit], na.rm=TRUE)
			  output <- list(convergence=outNM$convergence, mean=outNM$par[1], stdev=outNM$par[2], NLL=outNM$value, meanCI=c(mean.LCI, mean.UCI), stdevCI=c(stdev.LCI, stdev.UCI))
			  }
			  else{
			    output <- list(convergence=NA, mean=NA, stdev=NA, NLL=NA, meanCI=c(NA, NA), stdevCI=c(NA, NA))
			  }
	return(output)
}



